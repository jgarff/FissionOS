#
# cortexm.py
#
# 
# Copyright (c) 2013-2017 Western Digital Corporation or its affiliates.
#
# Redistribution and use in source and binary forms, with or without modification,
# are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice,
#    this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution.
# 3. The name of the copyright holder nor the names of its contributors may not
#    be used to endorse or promote products derived from this software without
#    specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
# HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
# Author: Jeremy Garff <jeremy.garff@sandisk.com>
#


# ARM Tools

import SCons
import os
import string
import struct
import array
import tarfile

def cortexm_flags(env):
    gnu_tools = ['gcc', 'g++', 'gnulink', 'ar', 'gas']
    for tool in gnu_tools:
        env.Tool(tool)   # This will ensure the normal Program, Object, etc.. work

    cflags = '''
        -D__EMBEDDED_STANDALONE__
        -O0
        -Wno-error=strict-aliasing
        -mthumb
        -Werror
        -Wall
        -g
        -ffunction-sections
        -fdata-sections
    '''.split()

    env['CFLAGS'] = cflags
    env['CPPPATH' ] = [
        '#/common',
    ]

    env['CC'] = 'arm-none-eabi-gcc'
    env['LINK'] = 'arm-none-eabi-gcc'
    env['AR'] = 'arm-none-eabi-gcc-ar'
    env['RANLIB'] = 'arm-none-eabi-gcc-ranlib'
    env['OBJCOPY'] = 'arm-none-eabi-objcopy'

    # Build a specially formed command line to include the libs
    # given the quirks of gcc.  ${LINKSCRIPT} must be defined for
    # the appropriate environment (app, bootloader, etc.).
    link = '''
        --specs=nano.specs
        -mthumb
        -nostartfiles
        -Wl,--relax
        -Wl,--gc-sections
        -T${LINKSCRIPT}
        '''.split()

    env.Append(
        LINKFLAGS = link
    )

    # Verbose?
    if not env['V']:
        env.Append(
            VERBOSE =      "/dev/null",

            CCCOMSTR     = "CC       ${TARGET}",
            ARCOMSTR     = "AR       ${TARGET}",
            RANLIBCOMSTR = "RANLIB   ${TARGET}",
            BINCOMSTR    = "Bin      ${TARGET}",
            HEXCOMSTR    = "Hex      ${TARGET}",
            ELFCOMSTR    = "Elf      ${TARGET}",
            IMGCOMSTR    = "Img      ${TARGET}",
            FWCOMSTR     = "Firmware ${TARGET}",
            UNTARCOMSTR  = "UnTar    ${SOURCE}",
            BUILDCOMSTR  = "Build    ${TARGETS}",
            APPLYCOMSTR  = "Apply    ${SOURCE}",
            USERSIGCOMSTR= "Usersig  ${SOURCE}",
            SECTIONCOMSTR= "Sections ${TARGET}",
            PDICOMSTR    = "PDI      ${TARGET}",
            CGENCOMSTR   = "CGEN     ${TARGET}",
        )
    else:
        env.Append(
            VERBOSE =      "/dev/stdout"
        )


#
# Builder python functions
#
def cortexm_builders(env):
    def tar_info_to_node(object):
        return env.File(object.name)

    #
    # ROM Object C Code Builders
    #
    def create_csource_from_files(target, source, env):
        def generate_cobject(pathname, data):
            filename = pathname.split(os.sep)[-1];
            cobj_name = filename.replace('.', '_')

            objstr = "const uint8_t " + cobj_name + "[] =\n{\n    "
            j = 0
            for i in data:
                objstr = objstr + "0x%02x," % i
                j = j + 1
                if j > 15:
                    objstr = objstr + '\n    '
                    j = 0
            objstr = objstr + "\n};\n\n"

            return filename, cobj_name, objstr, len(data)

        def generate_cfile(target, source):
            f = open(target[0].abspath, 'w')
            f.write("/**** DO NOT EDIT ****  Automatically Generated by cortexm.py */\n")
            f.write("#include <stdint.h>\n")
            f.write("#include <lwip/api.h>\n")
            f.write("#include <lwip/ip.h>\n")
            f.write("#include <lwip/ip_addr.h>\n")
            f.write("#include <lwip/netif.h>\n")
            f.write("#include <lwip/tcpip.h>\n")
            f.write('\n')
            f.write('#include "http.h"\n')

            # Create all of the individual objects
            objs = []
            for s in source:
                source_data = [ord(x) for x in file(s.abspath).read()]
                filename, cobjname, source_code, length = generate_cobject(s.abspath, source_data)
                objs.append([ cobjname, filename, length ])
                f.write(source_code)

            # Create the master lookup table
            f.write("const http_page_table_t http_pages[] =\n{\n");
            for obj in objs:
                f.write("    {\n")
                f.write('        .name = "%s",\n' % obj[1])
                f.write("        .object = %s,\n" % obj[0])
                f.write("        .length = %s,\n" % obj[2])
                f.write("    },\n");
            f.write("};\n\n")
            f.write("const uint32_t http_page_table_count = %d;\n\n" % len(objs))
            f.close()

        generate_cfile(target, source)

    def tar_contents_emitter(target, source, env):
        env.Depends(target, source)
        try:
            tar = tarfile.open(source[0].get_abspath(), 'r')
        except IOError:
            return target, source
        contents = tar.getmembers()
        tar.close()
        files_only = filter(lambda entry: entry.isfile(), contents)
        updated_targets = map(tar_info_to_node, files_only)
        return updated_targets, source

    def untar(target, source, env):
        filename = source[0].get_abspath()
        pathname = os.path.dirname(source[0].get_abspath())
        tar = tarfile.open(filename, 'r')
        tar.extractall(path = pathname)
        tar.close()
        return None

    # CRC32, same algorithm used in ethernet, png, zip, etc..
    def crc32(data):
        crc_poly = 0xedb88320
        crc = 0xffffffff

        for d in data:
            b = (crc & 0xff) ^ d
            for r in range(8):
                if (b & 1):
                    b = ( b >> 1) ^ crc_poly;
                else:
                    b = (b >> 1)
            crc = (crc >> 8) ^ b

        return crc ^ 0xffffffff

    def create_usersig(target, source, env):
        data = [ord(x) for x in file(source[0].abspath, "rb").read()]
        size = len(data)
        crc = crc32(data)
        usersig = [
                     # crc - little endian
                     crc & 0xff,
                     (crc >> 8) & 0xff,
                     (crc >> 16) & 0xff,
                     (crc >> 24) & 0xff,
                     # size - little endian
                     size & 0xff,
                     (size >> 8) & 0xff,
                     (size >> 16) & 0xff,
                     (size >> 24) & 0xff,
                 ]
        outdata = array.array('B', usersig)
        outdata.tofile(file(target[0].abspath, "wb"))

    # Create binary and usersig size header file
    #
    # source[0] : Application binary file
    # source[1] : Usersig binary file
    def create_section_header(target, source, env):
        app_data = [ord(x) for x in file(source[0].abspath, 'rb').read()]
        app_size = len(app_data)
        usersig_data = [ord(x) for x in file(source[1].abspath, 'rb').read()]
        usersig_size = len(usersig_data)

        header = '/* ***** DO NOT MODIFY - Auto-generated by create_section_header **** */\n'
        header = header + '#define APP_LEN ' + str(app_size) + '\n'
        header = header + '#define USERSIG_LEN ' + str(usersig_size) + '\n'

        file(target[0].abspath, 'wb').write(header)

    def create_app_image(target, source, env):
        def create_app_header(source, dest):
            data = [ord(x) for x in file(source, "rb").read()]
            size = len(data)
            crc = crc32(data)

            major, minor, micro = (0, 0, 0)
            if 'VERSION' in env:
                major, minor, micro = env['VERSION']

            if env['V']:
                print "  Version : " + str(major) + "." + str(minor) + "." + str(micro)
                print "  Size    : " + str(size)
                print "  CRC     : " + hex(crc)

            header = [ # See boot.h for struct definition
                       # magic
                       0x43, 0x89,
                       # flags
                       0, 0,
                       # crc - little endian
                       crc & 0xff, (crc >> 8) & 0xff,
                       (crc >> 16) & 0xff, (crc >> 24) & 0xff,
                       # size - little endian
                       size & 0xff, (size >> 8) & 0xff,
                       (size >> 16) & 0xff, (size >> 24) & 0xff,
                       # version
                       int(major), int(minor), int(micro), 0,
                     ]

            outdata = array.array("B", header + data)
            outdata.tofile(file(dest, "wb"))

        create_app_header(source[0].abspath, target[0].abspath)

    def create_app_bl_image(target, source, env):
        def create_app_bl_header(source, dest):
            data = [ord(x) for x in file(source, "rb").read()]
            align = 64 - ((len(data) + 128) % 64)
            data = data + ([0] * align)

            size = len(data)
            crc = crc32(data)

            major, minor, micro, nano = (0, 0, 0, 0)
            if 'VERSION' in env:
                major, minor, micro = env['VERSION']

            if env['V']:
                print "  Version : " + str(major) + "." + str(minor) + "." + str(micro)
                print "  Size    : " + str(size)
                print "  CRC     : " + hex(crc)

            header = [ # magic
                       0x44, 0x89, 0xb0, 0x0b,
                       # flags
                       0, 0, 0, 0,
                       # crc - little endian
                       crc & 0xff, (crc >> 8) & 0xff,
                       (crc >> 16) & 0xff, (crc >> 24) & 0xff,
                       # size - little endian
                       size & 0xff, (size >> 8) & 0xff,
                       (size >> 16) & 0xff, (size >> 24) & 0xff,
                       # version
                       int(major), int(minor), int(micro), 0,
                     ] + [0] * 108 # desc

            outdata = array.array("B", header + data)
            outdata.tofile(file(dest, "wb"))

        create_app_bl_header(source[0].abspath, target[0].abspath)

    # Combined image with bootloader and application
    #
    # Make sure to pad the bootloader size out to the full section (80k)
    # See the .ld files to determine the proper size here
    def create_full_binary(target, source, env, max_boot_size = 80 * 1024):

        def pad_data(data, size):
            padded = data + ([0] * (size - len(data)))
            if len(padded) > size:
                raise Exception("Boot section too large")
            return padded

        boot_data = pad_data([ord(x) for x in file(source[0].abspath, "rb").read()], max_boot_size)
        app_data = [ord(x) for x in file(source[1].abspath, "rb").read()]

        all_data = array.array('B',  boot_data + app_data)
        all_data.tofile(file(target[0].abspath, "wb"))


    env.Append(BUILDERS = {
        'Elf': SCons.Builder.Builder(
            action = SCons.Action.Action("${LINK} ${LINKFLAGS} -Wl,--start-group ${SOURCES} -Wl,--end-group -lc -lm -o ${TARGET}", "${ELFCOMSTR}"),
            suffix = '.elf'
        ),
        'Hex' : SCons.Builder.Builder(
            action = SCons.Action.Action("${OBJCOPY} -O ihex ${SOURCES} ${TARGET}", "${HEXCOMSTR}"),
            suffix = '.hex'
        ),
        'Bin' : SCons.Builder.Builder(
            action = SCons.Action.Action("${OBJCOPY} -O binary ${SOURCES} ${TARGET}", "${BINCOMSTR}"),
            suffix = '.bin'
        ),
        'Usersig' : SCons.Builder.Builder(
            action = SCons.Action.Action(create_usersig, "${USERSIGCOMSTR}"),
            suffix = '.usersig'
        ),
        'Firmware' : SCons.Builder.Builder(
            action = SCons.Action.Action(create_app_image, "${FWCOMSTR}"),
            suffix = ".fw"
        ),
        'BLFirmware' : SCons.Builder.Builder(
            action = SCons.Action.Action(create_app_bl_image, "${FWCOMSTR}"),
            suffix = ".blfw"
        ),
        'SectionHeader' : SCons.Builder.Builder(
            action = SCons.Action.Action(create_section_header, "${SECTIONCOMSTR}"),
            suffix = '.h'
        ),
        'Image': SCons.Builder.Builder(
            action = SCons.Action.Action(create_full_binary, "${IMGCOMSTR}"),
            suffix = ".img"
        ),
        'UnTar' : SCons.Builder.Builder(
            action = SCons.Action.Action(untar, "${UNTARCOMSTR}"),
            emitter = tar_contents_emitter   # Update the ${TARGETS} to include all extracted files
        ),
        'CGen' : SCons.Builder.Builder(
            action = SCons.Action.Action(create_csource_from_files, "${CGENCOMSTR}"),
            suffix = '.c',
        ),
    })


#
# The following are required functions when using this via tools= in Environment()
#
def exists(env):
    return true

def generate(env, **kwargs):
    [ f(env) for f in (cortexm_flags, cortexm_builders) ]


